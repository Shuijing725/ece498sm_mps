from __future__ import division
import matplotlib
from math import *
import numpy as np
from numpy import linalg as LA 
import matplotlib.pyplot as plt
import argparse
from model import model
from scipy.optimize import fsolve

V_R = 10.0

# use np.arctan to find an angle, and correct it by +- 180 degrees if needed
# p1, p2: two points, each point is a 2-tuple (x, y)
def find_arctan(p1, p2):
	x1, y1 = p1
	x2, y2 = p2
	# since  -pi/2 <= alpha <= pi/2, alpha is now in 1st or 4th quadrant
	alpha = np.arctan((y2 - y1) / (x2 - x1))
	# print('alpha before conversion:', alpha / np.pi * 180)
	# if the angle is in 2nd or 3rd quadrant, add 180 degrees to correct it
	if x2 - x1 < 0:
		alpha += np.pi
	return alpha

def controller(state, state_d):
	# hyper-parameters
	eps = 0.01
	K = 0.01

	x, y, theta = state
	# print('init state: (', x, y, theta / np.pi * 280, ')')
	xd, yd = state_d
	#######################
	# Based on state and state_d
	# you need to calculate steering
	# angle such it goes towards state_d
	# You can use a controller very similar 
	# described in the MP write-up
	#########################

	alpha = find_arctan((x, y), (xd, yd)) - theta
	print('init alpha:', alpha / np.pi * 180)
	if np.abs(alpha) > eps:
		while np.abs(alpha) > eps:
			delta = K * alpha
			x, y, theta = model((x, y, theta), delta, V_R = 0)
			alpha = find_arctan((x, y), (xd, yd)) - theta
			# print('(x, y, theta) = (', x, y, theta, '), alpha:', alpha, ', delta:', delta)
		return theta, 0

	else:
		v = ((yd - y)**2 + (xd - x)**2) / 100
		return 0, v

def SELECT_INPUT(state, reach_state, obstacle_map = None, show_plot = False, time_steps = 1000):
	'''
	This will come up with a set of desired inputs such that the car drives from state ---> reach_state
	Input:
	state: current state of the car
	reach_state: the desired x,y position that you want the car to go
	obstacle_map: map of the world to check whether the path is safe or not
	show_plot: plotting the path generated by the controller (testing purposes only) keep this false
	time_steps: sanity check if the controller takes a long time then it breaks the loop
	Output:
	U: set of control inputs, data points along the pathway and other things that you think are necessary
	safe_check: whether the path computed by the controller is safe or not
	'''
	safe_check = True
	data = []
	x, y, theta = state
	x_d, y_d= reach_state
	
	dist = np.sqrt((x - x_d)**2 + (y - y_d)**2)
	i = 0
	eps = 0.01
	while (dist>eps): #add relevant values in abs()
		i += 1

		data.append(state)

		if obstacle_map is not None:		
			if ((int(x) >= 1000) | (int(x) <= 0)  | ((int(y) >= 1000) | (int(y) <= 0))):
				safe_check = False
				break
			if (obstacle_map[int(x), int(y)] == (0, 0, 0)):#(0, 0, 0)
				safe_check = False 
				break
		if show_plot:
			print ('state:', state, 'iterations:', i)
			plt.plot(x, y, 'ro')

		x, y, theta = state
		delta, v = controller(state, reach_state) # output two values one for steering and one for V_R
		# UPDATE MODEL
		state = model(state, delta, V_R = v)
		#update new distance
        	dist = np.sqrt((x - x_d)**2 + (y - y_d)**2)
		
		if i > time_steps:
			safe_check = False
			break
	################################

	return data, safe_check

def test(state, reach_state):
	plt.plot([state[0], reach_state[0]], [state[1], reach_state[1]])
	SELECT_INPUT(state, reach_state, show_plot = True, time_steps = 1500)
	plt.show()
	# print(model((-10, 10, np.pi), 0, 10))


state = np.array([0, 0, 0.0])
test(state, np.array([-10,100]))




